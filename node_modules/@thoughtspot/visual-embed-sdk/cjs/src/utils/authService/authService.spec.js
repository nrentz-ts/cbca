"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const logger_1 = require("../logger");
const thoughtSpotHost = 'http://10.79.135.124:3000';
const authVerificationUrl = 'http://localhost:3000';
const authEndpoint = '';
const username = 'tsuser';
const password = 'password';
const authToken = 'token';
describe('Unit test for authService', () => {
    beforeEach(() => {
        global.fetch = window.fetch;
    });
    test('fetchSessionInfoService', async () => {
        global.fetch = jest.fn(() => Promise.resolve({
            json: () => ({ success: true }),
            status: 200,
            ok: true,
        }));
        const response = await (0, _1.fetchSessionInfoService)(thoughtSpotHost);
        expect(response.success).toBe(true);
        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.SESSION_INFO}`, {
            credentials: 'include',
        });
    });
    test('fetchAuthTokenService', async () => {
        global.fetch = jest.fn(() => Promise.resolve({
            text: () => ({ success: true }),
            ok: true,
        }));
        const response = await (0, _1.fetchAuthTokenService)(authEndpoint);
        expect(response.text()).toStrictEqual({ success: true });
        expect(fetch).toBeCalled();
    });
    test('fetchAuthService', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.fetchAuthService)(thoughtSpotHost, username, authToken);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.TOKEN_LOGIN}?username=${username}&auth_token=${authToken}`, {
            credentials: 'include',
            redirect: 'manual',
        });
    });
    test('fetchAuthService without username', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.fetchAuthService)(thoughtSpotHost, undefined, authToken);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.TOKEN_LOGIN}?auth_token=${authToken}`, {
            credentials: 'include',
            redirect: 'manual',
        });
    });
    test('fetchAuthPostService', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.fetchAuthPostService)(thoughtSpotHost, username, authToken);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.TOKEN_LOGIN}`, {
            method: 'POST',
            credentials: 'include',
            redirect: 'manual',
            body: 'username=tsuser&auth_token=token',
            headers: {
                'content-type': 'application/x-www-form-urlencoded',
                'x-requested-by': 'ThoughtSpot',
            },
        });
    });
    test('fetchAuthPostService without username', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.fetchAuthPostService)(thoughtSpotHost, undefined, authToken);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.TOKEN_LOGIN}`, {
            method: 'POST',
            credentials: 'include',
            redirect: 'manual',
            body: 'auth_token=token',
            headers: {
                'content-type': 'application/x-www-form-urlencoded',
                'x-requested-by': 'ThoughtSpot',
            },
        });
    });
    test('fetchBasicAuthService called with manual redirect', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.fetchBasicAuthService)(thoughtSpotHost, username, password);
        expect(fetch).toBeCalled();
    });
    test('log error on API failures', async () => {
        jest.spyOn(logger_1.logger, 'error').mockImplementation(() => undefined);
        global.fetch = jest.fn(() => Promise.resolve({
            text: () => Promise.resolve('error'),
            status: 500,
            ok: false,
        }));
        try {
            await (0, _1.fetchSessionInfoService)(authVerificationUrl);
        }
        catch (e) {
            //
        }
        expect(logger_1.logger.error).toHaveBeenCalledWith('Failed to fetch http://localhost:3000/callosum/v1/session/info', 'error');
        try {
            await (0, _1.fetchBasicAuthService)(thoughtSpotHost, username, password);
        }
        catch (e) {
            expect(e.message).toContain('Failed to fetch session info');
        }
        expect(logger_1.logger.error).toHaveBeenCalledWith('Failure', 'error');
    });
    test('verifyTokenService if token api works', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ success: true, ok: true }));
        await (0, _1.verifyTokenService)(thoughtSpotHost, authToken);
        expect(fetch).toBeCalledWith(`${thoughtSpotHost}${_1.EndPoints.IS_ACTIVE}`, {
            credentials: 'omit',
            headers: {
                Authorization: `Bearer ${authToken}`,
                'x-requested-by': 'ThoughtSpot',
            },
        });
    });
    test('verifyTokenService if token api fails', async () => {
        global.fetch = jest.fn(() => Promise.reject(new Error('error')));
        jest.spyOn(logger_1.logger, 'warn');
        const status = await (0, _1.verifyTokenService)(thoughtSpotHost, authToken);
        expect(status).toBe(false);
        expect(logger_1.logger.warn).toHaveBeenCalledWith('Token Verification Service failed : error');
    });
});
//# sourceMappingURL=authService.spec.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const tokenizedFetchModule = tslib_1.__importStar(require("../../tokenizedFetch"));
const tokenizedAuthService_1 = require("./tokenizedAuthService");
const logger_1 = require("../logger");
const authService_1 = require("./authService");
const thoughtspotHost = 'http://thoughtspotHost';
describe('tokenizedAuthService', () => {
    afterEach(() => {
        jest.clearAllMocks();
        jest.restoreAllMocks();
    });
    test('isActiveService if fetch returns ok', async () => {
        jest.spyOn(tokenizedFetchModule, 'tokenizedFetch').mockResolvedValueOnce({
            ok: true,
        });
        const isActiveResp = await (0, tokenizedAuthService_1.isActiveService)('http://thoughtspotHost');
        expect(isActiveResp).toEqual(true);
    });
    test('isActiveService if fetch returns not ok', async () => {
        jest.spyOn(tokenizedFetchModule, 'tokenizedFetch').mockResolvedValueOnce({
            ok: false,
        });
        const isActiveResp = await (0, tokenizedAuthService_1.isActiveService)('http://thoughtspotHost');
        expect(isActiveResp).toEqual(false);
    });
    test('isActiveService if fetch fails', async () => {
        jest.spyOn(tokenizedFetchModule, 'tokenizedFetch').mockRejectedValueOnce({
            ok: false,
        });
        jest.spyOn(logger_1.logger, 'warn');
        const isActiveResp = await (0, tokenizedAuthService_1.isActiveService)('http://thoughtspotHost');
        expect(isActiveResp).toEqual(false);
        expect(logger_1.logger.warn).toHaveBeenCalled();
    });
});
describe('fetchPreauthInfoService', () => {
    afterEach(() => {
        jest.clearAllMocks();
        jest.restoreAllMocks();
    });
    test('fetchPreauthInfoService if fetch returns ok', async () => {
        const mockFetch = jest.spyOn(tokenizedFetchModule, 'tokenizedFetch');
        // Mock for fetchPreauthInfoService
        mockFetch
            .mockResolvedValueOnce({
            ok: true,
            headers: new Headers({ 'content-type': 'application/json' }),
            status: 200,
            statusText: 'Ok',
            json: jest.fn().mockResolvedValue({
                info: {
                    configInfo: {
                        mixpanelConfig: {
                            devSdkKey: 'devSdkKey',
                        },
                    },
                    userGUID: 'userGUID',
                },
            }),
        });
        const result = await (0, tokenizedAuthService_1.fetchPreauthInfoService)(thoughtspotHost);
        const response = await result.json();
        expect(mockFetch).toHaveBeenCalledTimes(1);
        expect(mockFetch).toHaveBeenNthCalledWith(1, `${thoughtspotHost}${authService_1.EndPoints.PREAUTH_INFO}`, {});
        expect(response).toHaveProperty('info');
    });
    it('fetchPreauthInfoService if fetch fails', async () => {
        const mockFetch = jest.spyOn(tokenizedFetchModule, 'tokenizedFetch');
        // Mock for fetchPreauthInfoService
        mockFetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: 'Internal Server Error',
            json: jest.fn().mockResolvedValue({}),
            text: jest.fn().mockResolvedValue('Internal Server Error'),
        });
        try {
            await (0, tokenizedAuthService_1.fetchPreauthInfoService)(thoughtspotHost);
        }
        catch (e) {
            expect(e.message).toContain(`Failed to fetch ${thoughtspotHost}${authService_1.EndPoints.PREAUTH_INFO}`);
        }
        expect(mockFetch).toHaveBeenCalledTimes(1);
        expect(mockFetch).toHaveBeenCalledWith(`${thoughtspotHost}${authService_1.EndPoints.PREAUTH_INFO}`, {});
    });
});
//# sourceMappingURL=tokenizedAuthService.spec.js.map
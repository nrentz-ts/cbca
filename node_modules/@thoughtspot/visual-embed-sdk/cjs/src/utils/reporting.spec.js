"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const embedConfig_1 = require("../embed/embedConfig");
const reporting_1 = require("./reporting");
const logger_1 = require("./logger");
const types_1 = require("../types");
const errors_1 = require("../errors");
jest.mock('./logger');
describe('ReportingObserver', () => {
    let mockReportingObserver;
    beforeAll(() => {
        // Mock the ReportingObserver
        mockReportingObserver = jest.fn().mockImplementation((callback, options) => ({
            observe: jest.fn(),
            disconnect: jest.fn(),
            takeRecords: jest.fn(),
        }));
        window.ReportingObserver = mockReportingObserver;
    });
    afterEach(() => {
        jest.clearAllMocks();
        (0, reporting_1.resetGlobalReportingObserver)();
    });
    test('should warn if ReportingObserver is not supported', () => {
        window.ReportingObserver = undefined;
        const observer = (0, reporting_1.registerReportingObserver)();
        expect(observer).toBeNull();
        expect(logger_1.logger.warn).toHaveBeenCalledWith('ReportingObserver not supported');
        window.ReportingObserver = mockReportingObserver;
    });
    test('should return existing globalObserver if override is false', () => {
        const firstObserver = (0, reporting_1.registerReportingObserver)();
        const secondObserver = (0, reporting_1.registerReportingObserver)();
        expect(firstObserver === secondObserver).toBe(true);
    });
    test('should override existing globalObserver if override is true', () => {
        const firstObserver = (0, reporting_1.registerReportingObserver)();
        const secondObserver = (0, reporting_1.registerReportingObserver)(true);
        expect(firstObserver).not.toBe(secondObserver);
    });
    test('should return globalObserver', () => {
        const observer = (0, reporting_1.registerReportingObserver)();
        const globalObserver = (0, reporting_1.getGlobalReportingObserver)();
        expect(globalObserver).toBe(observer);
    });
    test('Should register a global observer with callback', () => {
        let callBackPassed;
        // Mock the ReportingObserver
        const NewMockRO = jest.fn().mockImplementation((callback, options) => {
            callBackPassed = callback;
            return ({
                observe: jest.fn(),
                disconnect: jest.fn(),
                takeRecords: jest.fn(),
            });
        });
        const currentObserver = window.ReportingObserver;
        window.ReportingObserver = NewMockRO;
        (0, embedConfig_1.setEmbedConfig)({
            thoughtSpotHost: 'testHost',
            authType: types_1.AuthType.None,
        });
        const mockAlert = jest.fn();
        window.alert = mockAlert;
        const observer = (0, reporting_1.registerReportingObserver)();
        expect(observer).toBeDefined();
        expect(NewMockRO).toHaveBeenCalled();
        expect(callBackPassed).toBeDefined();
        // call the callback
        callBackPassed([{ type: 'csp-violation', url: 'testHost', body: { effectiveDirective: 'frame-ancestors' } }]);
        expect(mockAlert).toHaveBeenCalledWith(errors_1.ERROR_MESSAGE.CSP_VIOLATION_ALERT);
        expect(logger_1.logger.error).toHaveBeenCalledWith(errors_1.ERROR_MESSAGE.CSP_FRAME_HOST_VIOLATION_LOG_MESSAGE);
        window.ReportingObserver = currentObserver;
    });
});
//# sourceMappingURL=reporting.spec.js.map
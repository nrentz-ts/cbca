"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("jest-fetch-mock");
const base = tslib_1.__importStar(require("../../embed/base"));
const liveboardService_1 = require("./liveboardService");
describe('createLiveboardWithAnswers', () => {
    test('should create liveboard with answers', async () => {
        const answers = [
            {
                getTML: jest.fn().mockResolvedValue({
                    answer: {
                        search_query: '[revenue]',
                    },
                }),
            },
        ];
        const name = 'liveboard';
        const thoughtSpotHost = 'https://thoughtspot.example.com';
        const liveboardId = 'liveboardId';
        const lbTml = {
            guid: liveboardId,
            liveboard: {
                name,
                visualizations: [
                    {
                        id: 'Viz_0',
                        answer: {
                            search_query: '[revenue]',
                        },
                    },
                ],
                layout: {
                    tiles: [
                        {
                            visualization_id: 'Viz_0',
                            size: 'MEDIUM_SMALL',
                        },
                    ],
                },
            },
        };
        const result = {
            success: true,
        };
        fetchMock.mockResponseOnce(JSON.stringify([{ metadata_id: liveboardId }]));
        jest.spyOn(base, 'executeTML').mockResolvedValue(result);
        const res = await (0, liveboardService_1.createLiveboardWithAnswers)(answers, name);
        expect(res).toEqual(result);
        expect(base.executeTML).toHaveBeenCalledWith({
            metadata_tmls: [JSON.stringify(lbTml)],
            import_policy: 'ALL_OR_NONE',
        });
        fetchMock.mockResponseOnce(JSON.stringify([]));
        jest.spyOn(base, 'executeTML').mockResolvedValue(result);
        await (0, liveboardService_1.createLiveboardWithAnswers)(answers, name);
        delete lbTml.guid;
        expect(base.executeTML).toHaveBeenCalledWith({
            metadata_tmls: [JSON.stringify(lbTml)],
            import_policy: 'ALL_OR_NONE',
        });
    });
});
//# sourceMappingURL=liveboardService.spec.js.map
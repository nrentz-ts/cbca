"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const authToken_1 = require("./authToken");
const authServiceInstance = tslib_1.__importStar(require("./utils/authService/authService"));
const utils_1 = require("./utils");
const logger_1 = require("./utils/logger");
const errors_1 = require("./errors");
describe('AuthToken Unit tests', () => {
    test('getAuthenticationToken: When verification is disabled', async () => {
        jest.spyOn(authServiceInstance, 'verifyTokenService');
        const token = await (0, authToken_1.getAuthenticationToken)({
            getAuthToken: async () => 'abc3',
            disableTokenVerification: true,
        });
        expect(token).toBe('abc3');
        expect(authServiceInstance.verifyTokenService).not.toBeCalled();
    });
    test('getAuthenticationToken: When verification is enabled', async () => {
        (0, authToken_1.resetCachedAuthToken)();
        jest.clearAllMocks();
        jest.spyOn(authServiceInstance, 'verifyTokenService').mockImplementation(() => true);
        const token = await (0, authToken_1.getAuthenticationToken)({
            thoughtSpotHost: 'test',
            getAuthToken: async () => 'abc2',
            disableTokenVerification: false,
        });
        expect(token).toBe('abc2');
        expect(authServiceInstance.verifyTokenService).toBeCalledWith('test', 'abc2');
    });
    test('validateAuthToken : When token is invalid by type number', async () => {
        jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        const loggerSpy = jest.spyOn(logger_1.logger, 'error');
        const authToken = 123;
        const errorMessage = (0, utils_1.formatTemplate)(errors_1.ERROR_MESSAGE.INVALID_TOKEN_TYPE_ERROR, {
            invalidType: typeof authToken,
        });
        await expect((0, authToken_1.validateAuthToken)({
            thoughtSpotHost: 'test',
        }, authToken)).rejects.toThrow(errorMessage);
        expect(loggerSpy).toHaveBeenCalledWith(errorMessage);
        loggerSpy.mockRestore();
    });
    test('validateAuthToken : When token is invalid by type object', async () => {
        jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        const loggerSpy = jest.spyOn(logger_1.logger, 'error');
        const authToken = {};
        const errorMessage = (0, utils_1.formatTemplate)(errors_1.ERROR_MESSAGE.INVALID_TOKEN_TYPE_ERROR, {
            invalidType: typeof authToken,
        });
        await expect((0, authToken_1.validateAuthToken)({
            thoughtSpotHost: 'test',
        }, authToken)).rejects.toThrow(errorMessage);
        expect(loggerSpy).toHaveBeenCalledWith(errorMessage);
        loggerSpy.mockRestore();
    });
});
//# sourceMappingURL=authToken.spec.js.map